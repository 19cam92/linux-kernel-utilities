#!/bin/bash

# Requires `colors` - sourced in `functions`

get_arch(){
	echo -en "${Cyan} \_ Determining CPU type: "
	if [ "$(getconf LONG_BIT)" == "64" ]; then arch=amd64; else arch=i386; fi
	echo -e "${Yellow}${arch}${Reg}"
}

reqexit(){
	echo -e "${Red}Response not in the offered list of options. Interpreted as an exit request. Exiting.${Reg}"
	exit 0
}

check_qt(){
	
	printf '\t%-24s' "QT4 or QT5"
	if pkg-config --exists Qt5Core || pkg-config --exists QtCore; then \
		echo -e "${Green}Found${Reg}"; \
		return 0; \
	else \
		echo -e "${Red}Not Found${Reg}"; \
		return 1; \
	fi
}

check_deps(){
	for dep in $(echo ${DEPENDENCIES} | tr ' ' $'\n'); do
		printf '\t%-24s' "${dep}"
		if [[ -z `dpkg -l | grep "^ii  $dep"` ]]; then
			echo -e "${Red}Not Found${Reg}"
			UPDATENEEDED=1
		else
			echo -e "${Green}Found${Reg}"
		fi
	done
	echo ""
	if [ $UPDATENEEDED -eq 1 ]; then
		update
	fi
}

cleanup(){
	fakeroot rm $OUTPUT -f
}

get_debian_list(){
	for ver in $(curl -s https://kernel.org | grep "Download complete tarball" | cut -d '.' -f 2- | cut -d '"' -f 1); do
		TOTAL="${TOTAL}\nhttps://$ver"
	done
	echo -ne "\n"
	for ver in $(echo -e $TOTAL); do
		((COUNT++))
		printf ' %-3s Linux %-15s' "${COUNT})" "`echo ${ver##*'/'}|cut -d - -f 2- | sed 's/.tar.xz//g'`"
		[ $((COUNT%3)) -eq 0 ] && echo -e -n '\n'
	done
}

get_ubuntu_list(){
	for ver in $(curl -s ${BASEURL} | grep "v${MINVER}" | cut -d '>' -f 7 | awk '{print substr($0,1, length($0)-4)}'); do
		TOTAL="${TOTAL}\n$ver"
		DOWN="${DOWN}\n$ver"
	done
	echo -ne "\n"
	for ver in $(echo -e $TOTAL); do
		((COUNT++))
		printf ' %-3s Linux %-20s' "${COUNT})" "`echo ${ver##*'/'}|cut -d '>' -f 7 | sed 's/-$//'`"
		[ $((COUNT%4)) -eq 0 ] && echo -e -n '\n'
	done
}

print_kernels(){
	TOTAL1=""
	TOTAL2=""
	COUNT=0
	if [ "`basename "$0"`" = "compile_linux_kernel.sh" ]; then
		echo -e "Kernels Available from https://www.kernel.org:"
		get_debian_list
	elif [ "`basename "$0"`" = "update_ubuntu_kernel.sh" ]; then
		echo -e "${Cyan} \_ Precompiled kernels available from ${Yellow}kernel.ubuntu.com:${Reg}"
		get_ubuntu_list
	elif [ "`basename "$0"`" = "bats-exec-test" ]; then
		if [ "$1" = "debian" ]; then
			get_debian_list
		elif [ "$1" = "ubuntu" ]; then
			get_ubuntu_list
		fi
	else
		error "Func: Print_kernel" "Logic error in parsing latest kernel. Exiting." 1 
	fi
	
	NUMOPTS=$COUNT
	COUNT=0
}



select_kernel(){
	if [[ $USE_LATEST -eq 1 ]] ; then
		echo -e "\n\nScript started with ${Yellow}LATEST${Reg} option. Automating selection."
		if [ "`basename "$0"`" = "compile_linux_kernel.sh" ]; then
			INPUT=1
		elif [ "`basename "$0"`" = "update_ubuntu_kernel.sh" ]; then
			INPUT=$NUMOPTS
		elif [ "`basename "$0"`" = "bats-exec-test" ]; then
			INPUT=1
		else
			error "Func: Select_kernel" "Logic error in parsing latest kernel. Exiting." 1 
		fi
	else
		echo -n -e "\n\nSelect your desired kernel: "
		read INPUT
	
		# Check for non-integer
		if ! [ $INPUT -eq $INPUT 2>/dev/null ]; then
			reqexit
		fi
		# Check for non-offerred option
		if [ $INPUT -gt $NUMOPTS ]; then
			reqexit
		fi
	fi

	# Prompt for Ubuntu Low Latency kernel
	if [ "`basename "$0"`" = "update_ubuntu_kernel.sh" ]; then
		echo ""

		# Set low latency default to no	
		read -p "Do you want the lowlatency kernel? (y/[n]):" lowlatency
		case "$lowlatency" in
		   y* | Y*) lowlatency=1 ;;
		   *) lowlatency=0 ;;
		esac

		echo ""
	fi
	
}

get_precompiled_ubu_kernel(){
	get_arch
	for ver in $(echo -e $TOTAL); do
		((COUNT++))
		if [ $COUNT -eq $INPUT ]; then
			for verd in $(echo -e $DOWN); do
				((COUNTD++))
				if [ $COUNTD -eq $INPUT ]; then
					# Download Kernel
					if [ "$lowlatency" == "0" ]; then
						echo -e "${Cyan} \_ Locating source of ${ver} generic kernel packages.${Reg}"
						get_ubu_shared_header
						get_ubu_files generic header
						get_ubu_files generic image
					elif [ "$lowlatency" == "1" ]; then
						echo -e "${Cyan} \_ Locating source of ${ver} lowlatency kernel packages.${Reg}"
						get_ubu_shared_header
						get_ubu_files lowlatency header
						get_ubu_files lowlatency image
					fi
				fi				
			done
		fi
	done
	echo -e "${Cyan} \_ Done${Reg}\n"
}

get_ubu_shared_header(){
	echo -e "${Cyan} \_ Getting ${ver} shared header . . .${Reg}"
	eval curl -# -O $(lynx -dump -listonly -dont-wrap-pre ${BASEURL}${ver} | grep all | cut -d ' ' -f 4)
	err=$?
	if [ $err -ne 0 ]
	then
	    echo -e "Download package failure. Error code $err"
	    exit $err
	fi
}

get_ubu_files() {
	echo -e "${Cyan} \_ Getting ${ver} ${1} ${2}. . .${Reg}"
	eval curl -# -O $(lynx -dump -listonly -dont-wrap-pre ${BASEURL}${ver} | grep "$1" | grep "$2" | grep "$arch" | cut -d ' ' -f 4)
	err=$?
	if [ $err -ne 0 ]
	then
	    echo -e "Download package failure. Error code $err"
	    exit $err
	fi
}

get_kernel_archive(){
	echo ""
	for ver in $(echo -e $TOTAL); do
		((COUNT++))
		if [ $COUNT -eq $INPUT ]; then
			echo -e "${PLUS} Downloading Kernel"
			echo -e " \_ Saving as ${Cyan}${OUTPUT}${Reg}"
			echo -e "\nURL: ${ver}     Output: ${OUTPUT}\n"
			TEMPFILES+=( "$OUTPUT" )
			eval curl -# $ver -o "$OUTPUT"
			err=$?
			if [ $err -ne 0 ]
			then
				error "Func: print_kernels" "Download source failure." $err
			fi
			
			SIGNurl=`sed 's/.xz/.sign/g' <<< ${ver}`
            SIGNfile=`sed 's/.xz/.sign/g' <<< ${OUTPUT}`
            TEMPFILES+=( "$SIGNfile" )
            echo -e "${PLUS} Downloading Signature"
			echo -e " \_ Saving as ${Cyan}${SIGNfile}${Reg}"
			echo -e "\nURL: ${SIGNurl}     Output: ${SIGNfile}\n"
            eval curl -# $SIGNurl -o "$SIGNfile"
			err=$?
			if [ $err -ne 0 ]
			then
				error "Func: print_kernels" "Download signature file failed." $err
			fi
		fi
	done
}

install_key(){
    gpg --keyserver pgp.mit.edu --recv-keys $CHK_ID --keyserver
}

spinner(){
	local pid=$1
	local delay=0.175
	local spinstr='|/-\'
	tput civis;
	local infotext=$2
	while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
		local temp=${spinstr#?}
		printf "[%c] %s" "$spinstr" "$infotext"
		local spinstr=$temp${spinstr%"$temp"}
		sleep $delay
		printf "\b\b\b\b\b\b"
		for i in $(seq 1 ${#infotext}); do
			printf "\b"
		done
	done
	printf " \b\b\b\b"
	tput cnorm;
}

update(){
	echo -e "${PLUS} Dependencies"
	sudobg apt-get update > /dev/null 2>&1
	MSG="Working . . . "
	spinner $BGPID "$MSG"
	wait $BGPID
	printf "%-20s" " \_ Updating APT"
	echo -e "${Green}Complete${Reg}"
	printf "%-20s" " \_ Installing dependencies"
	echo
	sudobg DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::="--force-confnew" -qq install $DEPENDENCIES > /dev/null 2>&1
	MSG="Working, this one may take a while . . ."
	spinner $BGPID "$MSG"
	wait $BGPID
	echo -ne "\033[2K" ; printf "\r"
	printf "%-20s" " \_ Installation"
	echo -e "${Green}Complete${Reg}\n"
}

countdown(){
	local txt=$1
	local secs=$2
	while [ $secs -gt 0 ]; do
	echo -ne "$txt $secs\033[0K\r"
	sleep 1
	: $((secs--))
	done
}

sudobg() {
	sudo echo ""
	echo
  	$SUDO "$@" > /dev/null 2>&1 &
	BGPID=$!
}

# TRAPS
TEMPFILES=( )
cleanupfiles() {
  rm -f "${TEMPFILES[@]}"
}
trap cleanupfiles 0

check_sign(){
    echo -e "\n${PLUS} Checking archive signature"
    CHK_SIGN=`unxz -c ${OUTPUT} | gpg --verify ${SIGNfile} - 2>&1`
    CHK_SIGN_MISS_SIG=`grep -o 'public key not found' <<<$CHK_SIGN`

    CHK_ID=`grep -Po -- 'RSA key ID \K\w*' <<< "$CHK_SIGN"`

    if [[ "$CHK_SIGN_MISS_SIG" == "public key not found" ]] ; then
        echo -e "\n[!] The public key for this file was not found in your PGP store."
        echo -e "[?] Do you want to install ID $CHK_ID:"
        echo -e "    [Y]es  - Install the RSA key ID for ${Yellow}$CHK_ID${Reg}"
        echo -e "    [n]o   - Do NOT install ID and EXIT"
        echo -e "    [s]kip - Do NOT install ID and CONTINUE"
	
        echo -n -e "\n\nSelect your desired action: "
        read INSTALL_ID
    
        case $INSTALL_ID in
            [Nn]*) 
                echo -e "No"
                exit 0;
                ;;
            [Ss]*) 
                echo -e "Skip"
                ;;
            *) echo -e "Yes"
                install_key
                check_sign
        esac
    else
        CHK_SIGN_VALID=`grep -Po -- 'Good signature from' <<< "$CHK_SIGN"`
        if [[ "$CHK_SIGN_VALID" == "Good signature from" ]] ; then
            echo -e " \_ Signature validated: ${Green}$CHK_ID${Reg}\n"
        else
			error "Func: chk_sign" "Signature invalid. Exiting." 1 
        fi
    fi
}

usage(){
	echo -e "\n TO DO: Create usage feedback"
	exit 0
}
